<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

	<!--Write mod.yaml file-->
	<Target Name="GenerateModYaml" BeforeTargets="PrepareForRun" Condition="'$(DoNotBuildAsMod)' != 'true'">
		<ItemGroup>
			<ModLines Include="title: '$(ModName)'"/>
			<ModLines Include="description: &quot;$([System.String]::Copy('$(ModDescription)').Replace('&quot;', '\&quot;'))&quot;"/>
			<ModLines Include="staticID: $(AssemblyName)"/>
			<!--<ModLines Include="steamID: $(SteamId)" Condition="'$(SteamId)' != ''"/>--> <!--Causes recoverable parse errors :/-->
		</ItemGroup>
		<WriteLinesToFile File="$(TargetDir)/mod.yaml" Overwrite="true" Lines="@(ModLines)"/>
    <ItemGroup>
      <FileWrites Include="$(TargetDir)/mod.yaml" Condition="Exists('$(TargetDir)/mod.yaml')"/>
    </ItemGroup>
	</Target>
	<!--Write mod_info.yaml file-->
	<Target Name="GenerateModInfoYaml" BeforeTargets="PrepareForRun" Condition="'$(DoNotBuildAsMod)' != 'true'">
		<ItemGroup>
			<ModInfoLines Include="minimumSupportedBuild: $(TargetGameVersion)"/>
			<ModInfoLines Include="version: $(Version)"/>
			<ModInfoLines Include="APIVersion: 2"/>
			<ModInfoLines Include="requiredDlcIds:" Condition="'$(RequiredDlcIds)' != ''"/>
			<ModInfoLines Include="$([System.String]::Copy('$(RequiredDlcIds)').Insert(0,' - ').Replace(',','%0a- '))" Condition="'$(RequiredDlcIds)' != ''"/>
			<ModInfoLines Include="forbiddenDlcIds:" Condition="'$(ForbiddenDlcIds)' != ''"/>
			<ModInfoLines Include="$([System.String]::Copy('$(ForbiddenDlcIds)').Insert(0,' - ').Replace(',','%0a- '))" Condition="'$(ForbiddenDlcIds)' != ''"/>
		</ItemGroup>
		<WriteLinesToFile File="$(TargetDir)/mod_info.yaml" Overwrite="true" Lines="@(ModInfoLines)"/>
    <ItemGroup>
      <FileWrites Include="$(TargetDir)/mod_info.yaml" Condition="Exists('$(TargetDir)/mod_info.yaml')"/>
    </ItemGroup>
	</Target>
	<!--Write LauncherMetadata.json file for Romen ModLauncher and SgtsModUpdater-->
	<Target Name="GenerateLauncherMetadata" BeforeTargets="PrepareForRun" Condition="'$(DoNotBuildAsMod)' != 'true'">
		<ItemGroup>
			<LauncherMetadataLines Include='{'/>
			<LauncherMetadataLines Include='"UpdateIndexName":"Mods by Sgt_Imalas",'/>
			<LauncherMetadataLines Include='"UpdateIndexURL":"https://github.com/Sgt-Imalas/Sgt_Imalas-Oni-Mods/releases/download/AllMods_Automated_Build_FullRelease/_ReleaseVersionInfoData.json",'/>
			<LauncherMetadataLines Include='"BugReportURL":"https://github.com/Sgt-Imalas/Sgt_Imalas-Oni-Mods/issues/new/choose",'/>
			<LauncherMetadataLines Include='"RepoURL":"https://github.com/Sgt-Imalas/Sgt_Imalas-Oni-Mods",'/>
			<LauncherMetadataLines Include='"Author":"$(Authors)"'/>			
			<LauncherMetadataLines Include='}'/>
		</ItemGroup>
		<WriteLinesToFile File="$(TargetDir)/LauncherMetadata.json" Overwrite="true" Lines="@(LauncherMetadataLines)"/>
    <ItemGroup>
      <FileWrites Include="$(TargetDir)/LauncherMetadata.json" Condition="Exists('$(TargetDir)/LauncherMetadata.json')"/>
    </ItemGroup>
	</Target>

	<!--
	Target PrepareForRepack prepares repacked output based on the following properties:
		$(RepackBuildOutput): Enable to repack merged assemblies '.dll'. Default: 'true'.
		$(RepackOutputSymbols): Enable to repack merged debug symbols '.pdb'. Default: 'true'.
		$(RepackDocumentationFile): Enable to repack merged documentation '.xml'. Default: 'true'.
		$(RepackInternalize): Enable to change accessibility from public to internal for metadata in merged assemblies. Default: 'false'.
	To exclude specific repacked output, override and disable the corresponding property.
	-->
	<Target Name="PrepareForRepack" DependsOnTargets="Compile">
		<!--Enumerate merge assemblies with metadata keys to match related files '.pdb' and '.xml'.-->
		<ItemGroup>
			<ReferenceCopyLocalPaths Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' == ''">
				<ParentDirectory>$([System.IO.Path]::GetDirectoryName('%(Identity)'))</ParentDirectory>
			</ReferenceCopyLocalPaths>
			<RepackMergeAssemblies
				Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension', '.dll')->HasMetadata('ParentDirectory'))"
				KeepMetadata="ParentDirectory"/>
			<RepackMergeAssemblies
				Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension', '.dll')->HasMetadata('NugetPackageId'))"
				KeepMetadata="NuGetPackageId;NuGetPackageVersion;AssetType"/>
			<RepackLibraryPaths
				Include="@(ReferencePath->DirectoryName()->Distinct())"
				Condition="'%(ReferencePath.CopyLocal)' == 'false'"/>
		</ItemGroup>
		<PropertyGroup>
			<!--NOTE: All repacked output artifacts require $(RepackBuildOutput)='true'.-->
			<RepackBuildOutput Condition="'$(RepackBuildOutput)' == ''">true</RepackBuildOutput>
			<RepackOutputSymbols Condition="'$(RepackOutputSymbols)' == ''">true</RepackOutputSymbols>
			<RepackDocumentationFile Condition="'$(RepackDocumentationFile)' == ''">true</RepackDocumentationFile>
			<RepackInternalize Condition="'$(RepackInternalize)' == ''">false</RepackInternalize>
			<NumRepackMergeAssemblies>@(RepackMergeAssemblies->Count())</NumRepackMergeAssemblies>
		</PropertyGroup>
		<!--Suggest two potential build optimizations.-->
		<Warning
			Text="Found dependency assemblies to repack, but repacking assemblies is disabled. Consider RepackBuildOutput='true'."
			Condition="$(NumRepackMergeAssemblies) > 0 and !$(RepackBuildOutput)"
			File="$(MSBuildThisFile)"
			Code="ILR2001"/>
		<Warning
			Text="No dependency assemblies to repack. Consider RepackBuildOutput='false'."
			Condition="$(NumRepackMergeAssemblies) == 0 and $(RepackBuildOutput)"
			File="$(MSBuildThisFile)"
			Code="ILR2002"/>
		<!--To prevent clobbered output, disable default copies to output 'bin'.-->
		<PropertyGroup Condition="$(NumRepackMergeAssemblies) > 0">
			<CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)' == ''">false</CopyBuildOutputToOutputDirectory>
			<CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)' == ''">false</CopyOutputSymbolsToOutputDirectory>
			<CopyDocumentationFileToOutputDirectory Condition="'$(CopyDocumentationFileToOutputDirectory)' == ''">false</CopyDocumentationFileToOutputDirectory>
		</PropertyGroup>
		<!--Consume input assemblies '.dll' for repacking.-->
		<ItemGroup>
			<RepackMergeAssemblies Remove="@(RepackMergeAssemblies)" Condition="!$(RepackBuildOutput)"/>
			<ReferenceCopyLocalPaths Remove="@(RepackMergeAssemblies)"/>
		</ItemGroup>
		<!--Consume related debug symbols files '.pdb' for repacking.-->
		<ItemGroup Condition="$(RepackOutputSymbols)">
			<ReferenceCopyLocalPaths
				Remove="@(RepackMergeAssemblies)"
				MatchOnMetadata="NuGetPackageId;NuGetPackageVersion;AssetType"
				Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != '' and '%(ReferenceCopyLocalPaths.Extension)' == '.pdb'"/>
			<ReferenceCopyLocalPaths
				Remove="@(RepackMergeAssemblies)"
				MatchOnMetadata="ParentDirectory;Filename"
				Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' == '' and '%(ReferenceCopyLocalPaths.Extension)' == '.pdb'"/>
		</ItemGroup>
		<!--Consume related documentation files '.xml' for repacking.-->
		<ItemGroup Condition="$(RepackDocumentationFile)">
			<ReferenceCopyLocalPaths
				Remove="@(RepackMergeAssemblies)"
				MatchOnMetadata="NuGetPackageId;NuGetPackageVersion;AssetType"
				Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != '' and '%(ReferenceCopyLocalPaths.Extension)' == '.xml'"/>
			<ReferenceCopyLocalPaths
				Remove="@(RepackMergeAssemblies)"
				MatchOnMetadata="ParentDirectory;Filename"
				Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' == '' and '%(ReferenceCopyLocalPaths.Extension)' == '.xml'"/>
		</ItemGroup>
		<!--Log diagnostics if any dependency artifacts remain, i.e. copies to output 'bin'.-->
		<PropertyGroup>
			<_NumRepackSkipArtifacts>@(ReferenceCopyLocalPaths->Count())</_NumRepackSkipArtifacts>
			<_SkipArtifactsPath Condition="$(_NumRepackSkipArtifacts) > 0">$(IntermediateOutputPath)ILRepack.SkipArtifacts.txt</_SkipArtifactsPath>
		</PropertyGroup>
		<WriteLinesToFile
			File="$(_SkipArtifactsPath)"
			Lines="@(ReferenceCopyLocalPaths)"
			Overwrite="true"
			Condition="$(_NumRepackSkipArtifacts) > 0"/>
		<ItemGroup Condition="Exists('$(_SkipArtifactsPath)')">
			<FileWrites Include="$(_SkipArtifactsPath)"/>
		</ItemGroup>
		<Warning
			Text="Skipped repacking $(_NumRepackSkipArtifacts) dependency artifacts (see '$(_SkipArtifactsPath)'). By default, artifacts copy to output 'bin'."
			Condition="$(_NumRepackSkipArtifacts) > 0"
			File="$(MSBuildThisFile)"
			Code="ILR2003"/>
	</Target>

	<!--
	Target ILRepack has three output artifacts as items:
		@(MainAssembly): Repacked '.dll' from merged assemblies.
		@(_DebugSymbolsOutputPath): Repacked '.pdb' from merged debug symbols.
		@(FinalDocFile): Repacked '.xml' from documentation.
	The output artifacts are rebuilt if any of the corresponding transitive inputs are outdated.
	-->
	<Target
		Name="ILRepack"
		DependsOnTargets="PrepareForRepack;CopyFilesToOutputDirectory"
		Inputs="@(IntermediateAssembly);@(_DebugSymbolsIntermediatePath);@(DocFileItem)"
		Outputs="$(TargetPath);@(_DebugSymbolsOutputPath);@(FinalDocFile)"
		Condition="'$(RepackBuildOutput)' == 'true'">
		<!--Suggest potential build optimizations.-->
		<Warning
			Text="Potentially clobbering assemblies '.dll'. Consider CopyBuildOutputToOutputDirectory='false'."
			Condition="$(RepackBuildOutput) and $(CopyBuildOutputToOutputDirectory)"
			File="$(MSBuildThisFile)"
			Code="ILR2004"/>
		<Warning
			Text="Potentially clobbering debug symbols '.pdb'. Consider CopyOutputSymbolsToOutputDirectory='false'."
			Condition="$(RepackOutputSymbols) and $(CopyOutputSymbolsToOutputDirectory) and $(_DebugSymbolsProduced)"
			File="$(MSBuildThisFile)"
			Code="ILR2004"/>
		<Warning
			Text="Potentially clobbering documentation '.xml'. Consider CopyDocumentationFileToOutputDirectory='false'."
			Condition="$(RepackDocumentationFile) and $(CopyDocumentationFileToOutputDirectory) and $(_DocumentationFileProduced)"
			File="$(MSBuildThisFile)"
			Code="ILR2004"/>

		<ILRepack
			TargetKind="SameAsPrimaryAssembly"
			Internalize="$(RepackInternalize)"
			LibraryPath="@(RepackLibraryPaths)"
			InputAssemblies="@(IntermediateAssembly);@(RepackMergeAssemblies)"
			XmlDocumentation="$(RepackDocumentationFile)"
			DebugInfo="$(RepackOutputSymbols)"
			OutputFile="$(TargetPath)"
			Condition="$(RepackBuildOutput)"/>

		<!--
		Mirror the behavior of target CopyFilesToOutputDirectory, which produces default artifacts in the output 'bin'.
		1. For items @(FilesWrites), include output artifacts ('.dll', '.pdb', and '.xml').
		2. For item @(MainAssembly), include output assembly ('.dll').
		3. Log item @(MainAssembly).
		-->
		<ItemGroup>
			<!--NOTE: To support MSBuild targets Clean and IncrementalClean, items @FileWrites cache paths at 'INTERMEDIATE_OUTPUT_PATH/*.FileListAbsolute.txt'. -->
			<MainAssembly Include="$(TargetPath)" Condition="$(RepackBuildOutput) and Exists('$(TargetPath)')"/>
			<FileWrites Include="@(MainAssembly)"/>
			<FileWrites Include="@(_DebugSymbolsOutputPath->Exists())" Condition="$(RepackBuildOutput) and $(RepackOutputSymbols)"/>
			<FileWrites Include="@(FinalDocFile->Exists())" Condition="$(RepackBuildOutput) and $(RepackDocumentationFile)"/>
		</ItemGroup>
		<Message
			Importance="High"
			Text="$(MSBuildProjectName) -> @(MainAssembly)"
			Condition="$(RepackBuildOutput) and Exists('@(MainAssembly)')"/>
	</Target>

	<PropertyGroup Condition="'$(IsPacked)' == 'true'">
		<!--Override the dependencies for PrepareForRun to control output to 'bin'.-->
		<PrepareForRunDependsOn>PrepareForRepack;ILRepack</PrepareForRunDependsOn>
	</PropertyGroup>

	<PropertyGroup>
		<TargetFolder Condition="'$(GameLibsFolder)' != '../Lib'">$(ModFolder)\$(TargetName)_dev\</TargetFolder>
		<TargetFolder Condition="'$(GameLibsFolder)' == '../Lib'">../Builds\$(TargetName)</TargetFolder>
	</PropertyGroup>

	<!--Copies the mod dll, the two yaml files and everything inside the ModAssets folder to the target mod folder-->
	<Target Name="CopyModsToDevFolder" AfterTargets="PrepareForRun" Condition="'$(DoNotBuildAsMod)' != 'true'">

		<Message Text="Executing CopyDLLs task" Importance="High" />

		<ItemGroup>
			<ModAssets
				Include = ".\ModAssets\**\*.*"
				Exclude = ".\**\*.afphoto;.\**\*.mo;.\**\*.afphoto~lock~"
				/>
		</ItemGroup>

		<Copy
		  SourceFiles="
			$(TargetDir)$(TargetName).dll;
			$(TargetDir)$(TargetName).pdb;
			$(TargetDir)mod.yaml;
			$(TargetDir)mod_info.yaml;
			$(TargetDir)LauncherMetadata.json;			
		  "
		  
		  DestinationFolder="$(TargetFolder)"/>

		<Message Text="Copy ModAssets to $(TargetFolder)" Importance="High"></Message>

		<Copy SourceFiles="@(ModAssets)" DestinationFolder="$(TargetFolder)\%(RecursiveDir)" SkipUnchangedFiles="false" />

		<Message Text="Copied build files" Importance="High" />

	</Target>

	<!--Create archive version-->
	<!--
	<Target Name="CopyModToArchive" AfterTargets="ILRepack" Condition="'$(AssemblyName)' != 'UtilLibs' and '$(AssemblyName)' != 'Util_TwitchIntegrationLib' and '$(GameLibsFolder)' != '../Lib'">

		<Message Text="Creating archive release.." Importance="High"/>

		<PropertyGroup>
			<CleanedModName>$(ModName.Replace('"','').Replace(";","").Replace(":","")</CleanedModName>
			<ArchiveTargetFolder>$(SolutionDir)Releases\$(CleanedModName)\$(CleanedModName)__$(Version)__$(MinimumSupportedBuild)\</ArchiveTargetFolder>
		</PropertyGroup>

		<ItemGroup>
			<ModAssets Include="$(TargetDir)\ModAssets\**\*.*" />
		</ItemGroup>

		<MakeDir Directories="$(ArchiveTargetFolder)"/>
		<Message Text="Archive Target: $(ArchiveTargetFolder)" Importance="High"></Message>


		<Copy
		  SourceFiles="
			$(TargetDir)$(TargetName).dll;
			$(TargetDir)mod.yaml;
			$(TargetDir)mod_info.yaml;"
		  
		  DestinationFolder="$(ArchiveTargetFolder)"/>

		<Message Text="Copy ModAssets to $(ArchiveTargetFolder)" Importance="High"></Message>

		<Copy SourceFiles="@(ModAssets)" DestinationFolder="$(ArchiveTargetFolder)\%(RecursiveDir)" SkipUnchangedFiles="false" />

		<Message Text="Copied archive files" Importance="High" />

	</Target>-->

	<!--Create folder for publicized dlls if not existing-->
	<Target Name="PubliciseMKDIR"
		BeforeTargets="Publicise"
		Condition="'$(GameLibsFolder)' != '../Lib' and '$(IsMod)' == 'true'"
		>
		<MakeDir Directories="$(SolutionDir)\PublicisedAssembly"/>
	</Target>

	<!--Creates publicized dlls from the game dlls-->
	<ItemGroup>
		<PubliciseAssemblies       Include="Assembly-CSharp.dll;Assembly-CSharp-firstpass.dll;"/>
		<PubliciseAssembliesInputs Include="@(PubliciseAssemblies->'$(GameLibsFolder)/%(Filename)%(Extension)')"/>
	</ItemGroup>
	<Target Name="Publicise"
		BeforeTargets="BeforeResolveReferences"
		Inputs="@(PubliciseAssembliesInputs)"
		Outputs="@(PubliciseAssembliesInputs->'$(SolutionDir)PublicisedAssembly\%(Filename)_public%(Extension)')"
		Condition="'$(GameLibsFolder)' != '../Lib' and '$(IsMod)' == 'true'"
		>

		<Publicise
			InputAssemblies="@(PubliciseAssembliesInputs)"
			OutputPath="$(SolutionDir)\PublicisedAssembly"
			PubliciseCompilerGenerated="false"
			/>
		<!--
		    Publicise also does internal incremental "compilation", and
		    doesn't change the timestamp on the target file when it does
		    nothing.  Which happens if, say, you were to test this by
		    touching the input DLL, so publicise sees no change (because
		    it checks the hash of the file), but MSBuild does.
		-->
		<!-- 
		     Worse, gotta copy the Outputs transform here, becuase MSBuild is terrible:
		     - it only identifies a mapping between input and output if `Outputs` is a transform, and
		     - it filters the `Inputs` list implicitly inside itself when incremental.
		-->
		<Touch Files="@(PubliciseAssembliesInputs->'$(SolutionDir)PublicisedAssembly\%(Filename)_public%(Extension)')" />
	</Target>

	<ItemGroup>
		<GameRefAssemblies Include="
					    Assembly-CSharp.dll;
					    Assembly-CSharp-firstpass.dll;
					    0Harmony.dll;
					    FMODUnity.dll;
					    Newtonsoft.Json.dll;
					    UnityEngine.dll;
					    UnityEngine.CoreModule.dll;
					    UnityEngine.ImageConversionModule.dll;
					    UnityEngine.AssetBundleModule.dll;
					    UnityEngine.PhysicsModule.dll;
					    UnityEngine.Physics2DModule.dll;
					    UnityEngine.ParticleSystemModule.dll;
					    UnityEngine.InputLegacyModule.dll;
					    Unity.TextMeshPro.dll;
					    UnityEngine.TextRenderingModule.dll;
					    UnityEngine.UI.dll;
					    UnityEngine.UIModule.dll;
					    UnityEngine.UnityWebRequestModule.dll;
					    Ionic.Zip.dll;
					    Newtonsoft.Json.dll;
					    com.rlabrecque.steamworks.net.dll;
					    netstandard.dll
					    " />
		<RefAssemblies Include="../PublicisedAssembly/*.dll; @(GameRefAssemblies->'$(GameLibsFolder)\%(Identity)')" />
	</ItemGroup>
	<Target Name="GenerateRefAssemblies"
		Inputs="@(RefAssemblies)"
		Outputs="@(RefAssemblies->'../Lib/%(Filename)%(Extension)')"
		AfterTargets="Publicise"
		BeforeTargets="BeforeResolveReferences"
		Condition="'$(GameLibsFolder)' != '../Lib' and '$(RefasmerInstalled)' != '0' and '$(IsMod)' == 'true'">

		<!--Workaround for paths containing spaces, e.g. "Program Files (x86)"-->
		<!--For some reason, adding the quotes to GameLibsFolder does not work-->
		<ItemGroup>
			<RefAsmerArguments Include="@(RefAssemblies -> '&quot;%(FullPath)&quot;', ' ')" />
		</ItemGroup>

		<Exec Command="Refasmer -v -O ../Lib --all -c @(RefAsmerArguments)" />
	</Target>
</Project>
